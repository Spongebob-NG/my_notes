好问题 👍 你现在学 Java 和 C++，容器和集合的理解特别关键。
 我先用 `vector` 作为例子，带你过一遍 **添加/删除**，再顺便总结一下常见 STL 容器的基本用法，方便你做笔记。

------

## 1. `vector` 的添加和删除

### 添加元素

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;

    // 尾部添加元素
    v.push_back(10);   // v = {10}
    v.push_back(20);   // v = {10, 20}

    // 插入元素
    v.insert(v.begin(), 5);              // 在开头插入 5 → {5, 10, 20}
    v.insert(v.begin() + 2, 15);         // 在索引 2 位置插入 15 → {5, 10, 15, 20}
    v.insert(v.end(), 2, 30);            // 在尾部插入两个 30 → {5, 10, 15, 20, 30, 30}

    // 输出
    for (int x : v) cout << x << " ";
}
```

### 删除元素

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {5, 10, 15, 20, 30, 30};

    v.pop_back();                       // 删除最后一个 → {5, 10, 15, 20, 30}
    v.erase(v.begin() + 1);             // 删除第二个元素(10) → {5, 15, 20, 30}
    v.erase(v.begin(), v.begin() + 2);  // 删除前两个元素 → {20, 30}
    v.clear();                          // 清空 → {}
}
```

------

## 2. 常见 STL 容器总结（重点笔记版）

### (1) `vector`

- 动态数组，支持随机访问。
- 常用操作：
  - `push_back(x)`：尾部加元素
  - `pop_back()`：尾部删元素
  - `insert(it, x)`：在迭代器位置插入
  - `erase(it)`：删除某个位置的元素
  - `erase(it1, it2)`：删除一段区间
  - `clear()`：清空
  - `size()`：大小
  - `empty()`：是否为空
  - `[] / at(i)`：访问第 i 个元素

------

### (2) `list`

- 双向链表，插入/删除快，随机访问慢。
- 操作：
  - `push_back(x), push_front(x)`
  - `pop_back(), pop_front()`
  - `insert(it, x), erase(it)`
  - `remove(x)`：删除所有值为 x 的元素
  - 遍历要用迭代器（不能像数组那样用下标）

------

### (3) `deque`（双端队列）

- 两端都能高效插入/删除。
- 操作和 `vector` 类似，还多了：
  - `push_front(x), pop_front()`

------

### (4) `stack`（栈）

- 后进先出（LIFO）。
- 操作：
  - `push(x), pop(), top(), empty(), size()`

------

### (5) `queue`（队列）

- 先进先出（FIFO）。
- 操作：
  - `push(x), pop(), front(), back(), empty(), size()`

------

### (6) `priority_queue`（优先队列 / 堆）

- 默认大顶堆（最大值在 top）。

- 操作：

  - `push(x), pop(), top()`

- 小顶堆写法：

  ```
  priority_queue<int, vector<int>, greater<int>> pq;
  ```

------

### (7) `set / multiset`

- `set`：自动有序、无重复。
- `multiset`：允许重复。
- 操作：
  - `insert(x), erase(x), find(x), count(x), size()`
  - 遍历自动按升序

------

### (8) `map / multimap`

- `map`：键值对，key 有序、唯一。

- `multimap`：key 可重复。

- 操作：

  ```
  map<string, int> mp;
  mp["apple"] = 3;
  mp["banana"] = 5;
  cout << mp["apple"];   // 3
  ```

------

### (9) `unordered_set / unordered_map`

- 和 `set/map` 类似，但用哈希表存储 → 无序，查询更快（平均 O(1)）。

------

✅ 总结口诀：

- **数组替代** → `vector`
- **链表需求** → `list`
- **两端插入/删除** → `deque`
- **栈** → `stack`
- **队列** → `queue`
- **优先取最大/最小** → `priority_queue`
- **有序不重复** → `set`
- **键值映射** → `map`
- **更快但无序** → `unordered_set / unordered_map`

## 1. 迭代器是什么？

你可以把 **迭代器** 理解成 **STL 容器的“指针”**。
 它的作用是 **指向容器里的某个元素**，并且能“走动”，从而遍历容器。

- 在 `vector` 里，迭代器就和数组的指针非常像。
- 在 `list`、`map` 这种不是连续存储的容器里，迭代器更重要，因为你没法用下标访问。

------

## 2. 基本操作

以 `vector` 为例：

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {10, 20, 30, 40, 50};

    // 定义迭代器，指向第一个元素
    vector<int>::iterator it = v.begin();

    cout << "第一个元素: " << *it << endl; // 解引用，输出 10

    // ++it 表示往后走一个元素
    ++it;
    cout << "第二个元素: " << *it << endl; // 输出 20

    // 遍历整个 vector
    for (vector<int>::iterator p = v.begin(); p != v.end(); ++p) {
        cout << *p << " ";
    }
    cout << endl;

    return 0;
}
```

输出：

```
第一个元素: 10
第二个元素: 20
10 20 30 40 50
```

------

## 3. 迭代器的常用方法

- `begin()`：返回指向第一个元素的迭代器
- `end()`：返回指向**最后一个元素的后面**的迭代器（注意，不是最后一个！所以循环用 `!= end()`）
- `*it`：解引用，取迭代器当前指向的值
- `++it` / `--it`：让迭代器前进/后退

------

## 4. 迭代器和删除元素

很多容器删除时必须用迭代器，因为删除可能让下标失效：

```
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};

    // 删除值为 3 的元素
    for (auto it = v.begin(); it != v.end(); ) {
        if (*it == 3) {
            it = v.erase(it); // erase 会返回下一个有效迭代器
        } else {
            ++it;
        }
    }

    // 输出结果
    for (int x : v) cout << x << " ";
    cout << endl;

    return 0;
}
```

输出：

```
1 2 4 5
```

------

## 5. 和指针的区别

- 指针是内存地址，可以操作任意数据。
- 迭代器是 **STL 容器专属的“安全指针”**，只能在容器内部移动，不随便越界。

------

👉 小总结：

- **迭代器 = 容器里的指针**
- `begin()` 指第一个，`end()` 指最后一个后面
- 用 `*it` 取值，用 `++it` 移动
- 删除元素时 `erase` 返回新的迭代器