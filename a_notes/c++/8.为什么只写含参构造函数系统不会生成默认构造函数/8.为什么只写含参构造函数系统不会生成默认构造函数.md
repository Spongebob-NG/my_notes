好嘞，那我给你讲一下为什么 ***只要你写了有参构造*，编译器就不再帮你生成默认构造函数** 👇

------

## 1. 编译器自动生成哪些函数？

如果你什么都不写，编译器会自动生成一些“默认成员函数”，包括：

- 默认构造函数
- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数

这就是所谓的 **Rule of Zero**。

------

## 2. 为什么写了有参构造就不再给你默认构造？

C++ 的设计者是为了**避免二义性**。

举个例子：

```
class A {
public:
    A(int x) { } // 你写了一个有参构造
};
```

如果编译器依然自动生成一个 `A()` 默认构造，那就会出现问题：

- 你到底是想让别人只能用 `A(x)` 来构造？
- 还是希望还可以 `A()`？

因为有可能你的设计就是 **必须传参才能创建对象**（比如强制要求对象有一个 ID）。
 所以 C++ 规定：
 👉 一旦你自己写了 **任何构造函数**，编译器就认为 **“你已经决定了构造逻辑”**，它就不再帮你自动生成默认构造函数。

------

## 3. 如果我既想要有参构造，又想要默认构造呢？

有两种办法：

### (1) 自己写一个默认构造函数

```
class A {
public:
    A() { }       // 显式默认构造
    A(int x) { }  // 含参构造
};
```

### (2) C++11 起，可以用 `= default`

```
class A {
public:
    A() = default;   // 告诉编译器：帮我生成一个默认构造
    A(int x) { }
};
```

这样你就可以同时拥有无参和有参构造了。

------

## 4. 小总结

- **不写构造 → 自动生成默认构造**。
- **只写有参构造 → 编译器不再生成默认构造**（必须自己写）。
- **想要两者都有 → 显式写上默认构造，或者用 `= default`**。