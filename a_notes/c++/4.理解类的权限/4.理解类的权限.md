C++ 中通过 `public`、`protected`和 `private`这三个关键字来控制类成员的访问权限，它们决定了类成员在何处可以被访问。下面我用一个表格来汇总它们的核心区别，然后再展开说明：

| 访问权限      | 类内部 | 派生类 | 类外部（通过对象） | 主要用途                                       |
| :------------ | :----- | :----- | :----------------- | :--------------------------------------------- |
| **public**    | ✅      | ✅      | ✅                  | 定义类的对外接口，供任何代码访问。             |
| **protected** | ✅      | ✅      | ❌                  | 定义希望派生类能继承使用，但不对外暴露的成员。 |
| **private**   | ✅      | ❌      | ❌                  | 隐藏类的实现细节，确保数据封装和安全。         |

### 🔍 详解各访问权限

#### 1. public（公有成员）

- •

  **定义**：使用 `public`关键字声明。

- •

  **访问规则**：**在类的内部、派生类中以及通过类的对象在类的外部都可以直接访问**。它定义了类与外界交互的接口

  。

  

- •

  **常见用途**：

  - •

    类的**构造函数**和**析构函数**

    。

    

  - •

    供外部调用的成员函数（即类的接口方法）

    。

    

  - •

    虽然技术上可以，但**通常不建议将数据成员设为 public**，除非有特殊理由（例如简单数据结构的 `struct`），因为这破坏了封装性

    。

    

#### 2. private（私有成员）

- •

  **定义**：使用 `private`关键字声明。

- •

  **访问规则**：**只能在定义它的类的内部被访问**（即由该类的其他成员函数访问）。在**类的外部**（包括通过对象）和**派生类中均无法直接访问**

  。

  

  - •

    使用 `class`关键字定义类时，**默认的访问权限是 private**

    。

    

- •

  **常见用途**：

  - •

    隐藏类的**内部实现细节和数据**（成员变量），防止外部代码随意修改，保证数据的安全性和一致性

    。

    

  - •

    那些仅在类内部使用，不希望外界知晓或调用的**辅助成员函数**

    。

    

  - •

    通过提供公有的 **getter**（读取）和 **setter**（设置）成员函数来间接访问和修改私有数据，从而可以在函数中添加**数据有效性验证**等逻辑

    。

    

#### 3. protected（受保护成员）

- •

  **定义**：使用 `protected`关键字声明。

- •

  **访问规则**：**允许在类的内部以及派生类中访问**。但在**类的外部**（通过对象）**无法直接访问**

  。它介于 `public`和 `private`之间。

  

- •

  **常见用途**：

  - •

    主要用于**继承**中。当你希望基类的某些成员能够被派生类访问和使用（继承），但又不想将这些成员完全公开给外部时，就将其设置为 `protected`

    。

    

### ⚠️ 重要补充说明

1. 1.

   **`class`vs `struct`**：在 C++ 中，`class`和 `struct`的唯一默认区别就是**默认访问权限**。

   - •

     使用 `class`定义的类，其成员**默认是 private**。

   - •

     使用 `struct`定义的结构体，其成员**默认是 public**

     。

     

2. 2.

   **友元（friend）**：`private`和 `protected`的访问限制可以被打破。通过使用 `friend`关键字，你可以授权特定的**友元函数**或**友元类**访问该类的所有私有（private）和受保护（protected）成员

   。这是一个例外机制，应谨慎使用。

   

### 🧪 简单代码示例

```
#include <iostream>
class Base {
public:    // 公有成员
    int publicVar;
    Base() : publicVar(0), protectedVar(0), privateVar(0) {} // 构造函数
    void publicMethod() {
        std::cout << "Public method can access: " << protectedVar << ", " << privateVar << std::endl;
    }

protected: // 受保护成员
    int protectedVar;

private:   // 私有成员
    int privateVar;
};

class Derived : public Base {
public:
    void accessBaseMembers() {
        publicVar = 1;      // OK: 派生类可访问基类 public 成员
        protectedVar = 2;   // OK: 派生类可访问基类 protected 成员
        // privateVar = 3;  // 错误：派生类不可访问基类 private 成员
    }
};

int main() {
    Base obj;
    obj.publicVar = 10;     // OK: 类外部可访问 public 成员
    obj.publicMethod();     // OK: 类外部可调用 public 成员函数
    
    // obj.protectedVar = 20; // 错误：类外部不可访问 protected 成员
    // obj.privateVar = 30;   // 错误：类外部不可访问 private 成员

    return 0;
}
```

### 💎 核心思想：封装

设置这些访问权限的核心目的是为了实现面向对象编程中的**封装**（Encapsulation）

。通过将内部数据和不希望暴露的实现细节设置为 `private`或 `protected`，只提供一个清晰的 `public`接口与外界交互，这样可以

：



- •

  **保证数据安全性和一致性**：避免数据被意外修改或赋予无效值。

- •

  **降低耦合度**：外部代码只依赖稳定的公共接口，而不依赖易变的内部实现。当内部实现改变时，只要接口不变，外部代码就无需修改。

- •

  **提高代码的可维护性和可复用性**。

希望这个更具体的解释能帮你更好地理解它们！