## 🧠 一、单调栈的核心思想

> **通过“单调性”快速找到每个元素左右两边第一个比它大/小的元素。**

- 单调递增栈：栈内元素从栈底到栈顶 **单调递增**。
   → 常用于找“**下一个更小元素**”。
- 单调递减栈：栈内元素从栈底到栈顶 **单调递减**。
   → 常用于找“**下一个更大元素**”。

栈里一般存的是**下标（index）**，方便计算距离或区间长度。

------

## 🧩 二、常见题型分类与例子

### ✅ 1. **找下一个更大/更小的元素**

**模板题：**

- LeetCode 739. 每日温度
- LeetCode 496. 下一个更大元素 I
- LeetCode 503. 下一个更大元素 II（循环数组）

**思路：**
 从右向左遍历数组，用栈保存“未找到更大元素”的元素下标。
 当遇到一个更大的数，就可以确定这些元素的“下一个更大值”。

**模板：**

```
vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> st; // 单调递减栈，存下标
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[st.top()] <= nums[i]) st.pop();
        if (!st.empty()) res[i] = nums[st.top()];
        st.push(i);
    }
    return res;
}
```

------

### ✅ 2. **计算区间 / 面积类问题**

**模板题：**

- LeetCode 84. 柱状图中最大的矩形
- LeetCode 85. 最大矩形（扩展84）
- LeetCode 42. 接雨水

**核心思路：**
 利用单调栈维护一个“递增高度栈”，每当遇到**更矮的柱子**时，就说明前面某一段的矩形面积到此为止，可以计算。

**举例（84题）：**

```
int largestRectangleArea(vector<int>& heights) {
    heights.push_back(0); // 哨兵
    stack<int> st;
    int maxArea = 0;
    for (int i = 0; i < heights.size(); i++) {
        while (!st.empty() && heights[i] < heights[st.top()]) {
            int h = heights[st.top()];
            st.pop();
            int left = st.empty() ? -1 : st.top();
            int w = i - left - 1;
            maxArea = max(maxArea, h * w);
        }
        st.push(i);
    }
    return maxArea;
}
```

------

### ✅ 3. **接雨水问题**

**模板题：**

- LeetCode 42. Trapping Rain Water

**思路：**
 用单调递减栈维护“下坡”形状，每当遇到更高的柱子，就能计算积水量。

------

### ✅ 4. **贡献法 / 范围统计问题**

**模板题：**

- LeetCode 907. 子数组的最小值之和
- LeetCode 2104. 子数组的最大值之和

**思路：**
 单调栈求出每个元素在多少个子数组中是最小/最大值，然后乘以贡献。

------

### ✅ 5. **股票问题 / 山峰山谷问题**

例如：

- 某天股票价格比前几天低多少？
- 找所有“山峰”的左右边界。

用单调递减栈可以高效找到这些位置。

------

## 🧭 三、单调栈的常见使用场景总结表

| 场景           | 栈类型   | 求解目标                        | 典型题目     |
| -------------- | -------- | ------------------------------- | ------------ |
| 下一个更大元素 | 单调递减 | 找右边第一个更大                | LeetCode 496 |
| 下一个更小元素 | 单调递增 | 找右边第一个更小                | 同类题       |
| 最大矩形面积   | 单调递增 | 找左右第一个比当前矮的柱子      | 84           |
| 接雨水         | 单调递减 | 模拟积水边界                    | 42           |
| 子数组最值贡献 | 单调栈   | 求每个数作为最值的区间长度      | 907、2104    |
| 区间左右边界   | 任意     | 用栈找左右第一个比它大/小的下标 | 模板通用     |

------

## 🔧 四、总结模板套路

**模板套路**
 （以求“左边第一个比当前小的元素下标”为例）：

```
vector<int> leftSmaller(vector<int>& a) {
    int n = a.size();
    vector<int> left(n, -1);
    stack<int> st;
    for (int i = 0; i < n; i++) {
        while (!st.empty() && a[st.top()] >= a[i]) st.pop();
        if (!st.empty()) left[i] = st.top();
        st.push(i);
    }
    return left;
}
```

------

## 🧩 五、记忆小口诀

> “**单调栈，找两边。更大更小分两栈。
>  遇矮算面积，遇高排雨量。**”