*先上代码：*

for (int i = 2; i <= n; i++) {
    if (IsPrime[i]) 
        prime[tot++] = i; // 如果 i 是质数，存到 prime 里
    
    for (int j = 0; j < tot; j++) {
        if (i * prime[j] > n) break;      // 防止越界
        IsPrime[i * prime[j]] = false;    // 用 prime[j] 去筛掉 i 的倍数
    
        if (i % prime[j] == 0) break;     // 如果 prime[j] 是 i 的最小质因子，停
    }
}

如果i%prime[j]==0的时候不停下的话，i就会和更大的质数去相乘，但是i和更大的质数相乘的结果肯定是会被比prime[j]更小的质数筛走的。比如说i=6时，prime[j]=2，这个时候不break的话，i会和下一个质数，也就是3相乘，6 *3=18。但是18肯定是要被2 *9筛掉的。

就这样理解吧，6=2×3->6%2==0->不break-> 18=2×9------->18=3×6->18=3×2×3->18=2×9，所以6%2==0的时候要break掉