好嘞，那我给你整理一份「整数运算小抄」📝，写题的时候你直接套公式就行。

------

# 🔑 常用整数运算技巧小抄（C++ / 算法题常用）

------

## 1. **向上取整**

普通除法会自动向下取整，要改成向上：

公式：

```
ceil(a / b) = (a + b - 1) / b   // a, b > 0
```

例子：

- `10 / 3 = 3` → `(10 + 2) / 3 = 4`
- `9 / 3 = 3` → `(9 + 2) / 3 = 3`

------

## 2. **判断整除**

判断 `a` 是否能被 `b` 整除：

```
a % b == 0
```

例子：

- `9 % 3 == 0` ✅
- `10 % 3 != 0`

------

## 3. **取模结果为正**

有时候取模可能出现负数（尤其是 C++ 和 Java）：

```
int mod = (a % b + b) % b;
```

这样保证结果范围在 `[0, b-1]`。

例子：

- `(-1 % 5 + 5) % 5 = 4`

------

## 4. **快速判断奇偶**

```
if (x & 1) // 奇数
else       // 偶数
```

位运算比 `% 2` 更快。

------

## 5. **整除向上倍数**

比如要把 `a` 补到 `b` 的整数倍：

```
int k = (a + b - 1) / b * b;
```

例子：

- `a=10, b=4 → 12`
- `a=12, b=4 → 12`

------

## 6. **区间中数个数**

整数区间 `[L, R]` 的长度：

```
int len = R - L + 1;
```

------

## 7. **整型溢出安全中点**

二分时求中点：

```
int mid = left + (right - left) / 2;
```

避免 `left + right` 溢出。

------

## 8. **交换两个数**

不用中间变量：

```
a ^= b;
b ^= a;
a ^= b;
```

（但实际用 `swap(a, b);` 更好 😂）

------

## 9. **最低位 1 的位置**

取出 `x` 的二进制中最低位的 1：

```
int lowbit = x & -x;
```

常用于树状数组、位运算。

------

## 10. **快速判断幂**

判断 `n` 是否是 2 的幂：

```
(n > 0) && ((n & (n - 1)) == 0)
```

------

# 📝 总结口诀

- **向上整**：`(a + b - 1) / b`
- **取模正**：`(a % b + b) % b`
- **中点防溢**：`mid = l + (r - l)/2`
- **奇偶看位**：`x & 1`
- **2 的幂**：`x & (x-1)`





你提供的这段代码 `a ^= b; b ^= a; a ^= b;` 是利用**异或运算（XOR）** 的特性来交换两个整型变量的值，而不需要额外的临时变量

。下面我们来看看它是如何一步步工作的。



为了更直观地理解这个过程，我们用一个具体的例子（a = 3, b = 5）来演示每一步的二进制计算和变量值的变化：

| 步骤         | 代码      | a的值 (二进制) | b的值 (二进制) | 说明                                                         |
| :----------- | :-------- | :------------- | :------------- | :----------------------------------------------------------- |
| **初始状态** |           | 3 (0011)       | 5 (0101)       | 变量初始值。                                                 |
| **第一步**   | `a ^= b;` | 6 (0110)       | 5 (0101)       | a 变为 a ^ b 的结果 (0011 ^ 0101 = 0110)                     |
| **第二步**   | `b ^= a;` | 6 (0110)       | 3 (0011)       | b 变为 b ^ a 的结果 (0101 ^ 0110 = 0011)，此时 b 已变为原来的 a |
| **第三步**   | `a ^= b;` | 5 (0101)       | 3 (0011)       | a 变为 a ^ b 的结果 (0110 ^ 0011 = 0101)，此时 a 变为原来的 b |

🧠 **基本原理**

异或运算（XOR，记作 `^`）有几个非常重要的性质，使得这种交换成为可能

：



- •**自反性**：`x ^ x = 0`，即一个数和自己异或结果为0。
- •**恒等性**：`x ^ 0 = x`，即任何数和0异或还是它自己。
- •**交换律和结合律**：`a ^ b = b ^ a`，`(a ^ b) ^ c = a ^ (b ^ c)`。

交换过程的核心思路是：**先将两个变量的信息“混合”保存在其中一个变量中，然后再利用异或的性质逐步“解混”并赋值，最终完成交换。**

🔢 **步骤解析**

1. 1.

   **第一步：`a = a ^ b`**
   此时变量 `a` 被赋予了 `a` 和 `b` 的异或值，可以看作是存储了两者混合的信息。变量 `b` 保持不变。

2. 2.

   **第二步：`b = a ^ b`**
   此时的 `a` 是 `(a0 ^ b0)`，所以这一步等价于 `b = (a0 ^ b0) ^ b0`。
   根据​**​结合律​**​：`(a0 ^ b0) ^ b0 = a0 ^ (b0 ^ b0)`
   根据​**​自反性​**​：`b0 ^ b0 = 0`，所以 `a0 ^ (b0 ^ b0) = a0 ^ 0`
   根据​**​恒等性​**​：`a0 ^ 0 = a0`
   于是，`b` 被成功赋值为原始的 `a` (`a0`)。此时 `a` 仍然是混合信息 `(a0 ^ b0)`。

3. 3.

   **第三步：`a = a ^ b`**
   此时的 `a` 是 `(a0 ^ b0)`，此时的 `b` 已经是原始的 `a` (`a0`)，所以这一步等价于 `a = (a0 ^ b0) ^ a0`。
   根据​**​交换律和结合律​**​：`(a0 ^ b0) ^ a0 = (a0 ^ a0) ^ b0`
   根据​**​自反性​**​：`a0 ^ a0 = 0`，所以 `(a0 ^ a0) ^ b0 = 0 ^ b0`
   根据​**​恒等性​**​：`0 ^ b0 = b0`
   于是，`a` 被成功赋值为原始的 `b` (`b0`)。交换完成。

⚠️ **注意事项与使用场景**

虽然这种方法很巧妙，但在实际编程中需要注意以下几点：

- •

  **仅适用于整数类型**：异或交换通常只适用于整数类型（如 `int`, `char`, `long` 等），因为异或是**位运算**。它不能直接用于交换浮点数或自定义对象

  。

- •

  **避免同一变量**：**必须确保交换的两个变量指向不同的内存地址**。如果试图用这种方法交换同一个变量（例如交换 `a[i]` 和 `a[j]` 而当 `i == j` 时），会导致该变量被置为0

  。因为根据自反性 `a ^ a = 0`。

- •

  **可读性与性能**：这种技巧的**可读性较差**，不如使用临时变量直观。在现代编译器的优化下，使用临时变量交换的方法性能通常很好，有时甚至更优，因为临时变量可能只存在于寄存器中

  。

💡 **总结**

`a ^= b; b ^= a; a ^= b;` 这行代码通过异或运算的**自反性**、**恒等性**、**交换律和结合律**，分三步巧妙地实现了两个整型变量值的交换，而无需借助临时变量

。



这是一种展示了位运算魅力的经典技巧，但在实际项目中选择它还是传统的临时变量法，需要权衡**可读性**、**安全性**和**适用性**