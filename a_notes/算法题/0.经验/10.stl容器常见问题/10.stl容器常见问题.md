## 🚩 STL 容器常见坑清单

### 1. 空容器访问元素

- **坑点**：对空容器调用 `front()`, `back()`, `top()`, `pop()`，都会触发未定义行为。

- **对策**：先 `empty()` 判断，再访问。

  ```
  if (!q.empty()) cout << q.front();
  ```

------

### 2. 下标越界

- **坑点**：`vector[i]` 或 `string[i]` 越界同样是 UB（未定义行为），不会像 Python 那样报错。

- **对策**：用 `.at(i)`（会抛异常）或者自己保证范围合法。

  ```
  vec.at(i); // 越界会抛出 std::out_of_range
  ```

------

### 3. 迭代器失效

- **坑点**：删除元素、插入元素时，已有迭代器可能会失效。

- **常见情况**：

  - `vector`：插入或删除元素 → 后面的迭代器全部失效。
  - `deque`：两端插入安全，中间插入可能失效。
  - `list` / `set` / `map`：删除某个元素的迭代器失效，但其他迭代器不受影响。

- **对策**：删元素时用返回值更新迭代器。

  ```
  for (auto it = v.begin(); it != v.end(); ) {
      if (*it % 2 == 0) it = v.erase(it); // erase 返回下一个有效迭代器
      else ++it;
  }
  ```

------

### 4. `erase` 和 `remove` 的区别

- **坑点**：`remove` 只是“搬移”不删除，容器大小不变。

- **对策**：要配合 `erase` 用。

  ```
  v.erase(remove(v.begin(), v.end(), 3), v.end());
  ```

------

### 5. 栈/队列不能遍历

- **坑点**：`stack` 和 `queue` 没有迭代器，不能用 `for(auto x: s)` 遍历。
- **对策**：需要 `while(!s.empty()) { ...; s.pop(); }`，或者用 `deque`/`vector` 替代。

------

### 6. 排序自定义比较函数

- **坑点**：`sort` 的比较函数必须是 **严格弱序**（不能写 `<=`）。

- **对策**：写 `return a < b;`，不要写 `<=`。

  ```
  sort(v.begin(), v.end(), [](int a, int b){ return a < b; });
  ```

------

### 7. map/unordered_map 的默认构造

- **坑点**：访问一个不存在的 key 时，`map[key]` 会自动插入一个默认值。

- **对策**：如果只是想查找，用 `.find()` 而不是 `[]`。

  ```
  if (m.find(10) != m.end()) cout << m[10];
  ```

------

### 8. string 和 C 风格字符串

- **坑点**：`string` 的 `.c_str()` 返回的是 `const char*`，不能直接修改。
- **对策**：如果要改，用 `&s[0]` 取得可修改的 buffer。

------

### 9. priority_queue 默认大顶堆

- **坑点**：默认是大顶堆，不是小顶堆。

- **对策**：小顶堆写法：

  ```
  priority_queue<int, vector<int>, greater<int>> pq;
  ```

------

### 10. set/multiset 的重复元素

- **坑点**：`set` 不能有重复元素，`insert` 相同值不会生效。
- **对策**：如果要存重复值，用 `multiset`。

### 11.stl的生命周期

**所有 STL 容器（`vector`, `deque`, `stack`, `queue`, `set`, `map` ...）都是普通类对象**。

- 如果你在一个作用域里定义它们（比如函数体、循环体），离开作用域就会自动调用 **析构函数**，释放里面的内存。
- 所以一般不需要手动 `delete` 或者担心泄漏。
- 唯一需要注意的是：如果你在容器里存的是 **指针**，那么容器销毁时只会销毁指针本身，不会释放指针指向的内存，这就需要你手动释放。

------

## ✅ 总结

- **容器空了不能访问**（最容易踩的坑）。
- **迭代器失效**（最阴险的坑）。
- **默认行为和直觉不同**（map 的 `[]`、priority_queue 的堆方向）。