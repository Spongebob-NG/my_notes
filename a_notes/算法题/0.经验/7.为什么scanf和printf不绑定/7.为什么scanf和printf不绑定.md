### 1️⃣ `cin` 和 `cout` 的绑定

在 C++ 中，默认情况下，`cin`（输入流）和 `cout`（输出流）是 **绑定在一起的**，目的是保证输入输出的顺序不会乱。

- 例如：

```
#include <iostream>
using namespace std;

int main() {
    int x;
    cout << "Enter a number: ";
    cin >> x;  // 因为绑定了，cout会先刷新缓冲区，把提示输出到屏幕
    return 0;
}
```

- 如果没有绑定或者不刷新输出，你可能看到提示 `"Enter a number: "` 不显示，程序就停在 `cin >> x` 等输入，这很容易让人误以为程序“卡住了”。

绑定背后的机制是：`cin` 在执行输入操作前，会自动调用 `cout.flush()`，确保之前的输出都显示出来。

------

### 2️⃣ `scanf` 和 `printf` 没有绑定

C 语言的 `scanf` 和 `printf` **没有这种绑定机制**，因为 C 标准库设计得比较底层：

- 输出是通过 **缓冲区** 管理的。
- 输入不会自动刷新输出缓冲区，所以如果你写：

```
#include <stdio.h>

int main() {
    int x;
    printf("Enter a number: "); // 可能不会马上显示到屏幕
    scanf("%d", &x);
    return 0;
}
```

有些情况下 `"Enter a number: "` 可能不会立即显示，需要手动刷新缓冲区：

```
fflush(stdout);
```

所以 C 里没有 `cin` 那样的绑定，但可以通过 `fflush(stdout)` 或者在字符串里加 `\n`（因为行缓冲的原因，`\n` 会让缓冲区自动刷新）来达到类似效果。

------

### 3️⃣ 关于 `\n` 和 `endl`

- `printf` 用 `\n` 换行即可。
- `endl` 是 C++ 的 `ostream` 成员，**只能用在 `cout`、`ofstream` 等 C++ 流里**，不能用在 `printf`。

另外：

```
cout << "Hello\n";   // 只是换行，不强制刷新缓冲区
cout << "Hello" << endl; // 换行 + 强制刷新缓冲区
```

所以 `printf` 一般用 `\n` 换行，如果想要立即刷新输出，需要加：

```
fflush(stdout);
```

------

### ✅ 总结

| 特性                 | C++ 流（cin/cout）    | C 函数（scanf/printf） |
| -------------------- | --------------------- | ---------------------- |
| 输入自动刷新输出     | 是（cin 会刷新 cout） | 否                     |
| 换行符               | `\n` 或 `endl`        | `\n`                   |
| 强制刷新缓冲区       | `endl`                | `fflush(stdout)`       |
| printf 能否用 endl？ | ❌（不是流）           | ❌                      |