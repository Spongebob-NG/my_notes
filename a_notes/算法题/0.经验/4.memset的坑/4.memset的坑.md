首先，memset要加#include<cstring>，不然洛谷会编译失败（但是vs2022可以，但最好是加）

你截图里显示的那些 `16843009`，正好就是 **memset 的坑**。我给你拆开说：

------

## 1. `memset` 是按 **字节** 设置的

```
memset(isprime, 1, sizeof(isprime));
```

这行的意思是：

- 把 `isprime` 这片内存的 **每个字节** 都设成 `0x01`。
- 但 `isprime` 是 `int` 数组，一个 `int` 占 4 个字节。
- 所以一个元素被写成 `0x01010101`。

------

## 2. 为什么调试里是 `16843009`

十六进制 `0x01010101` 转成十进制就是：

0x01010101=1+256+65536+16777216=168430090x01010101 = 1 + 256 + 65536 + 16777216 = 168430090x01010101=1+256+65536+16777216=16843009

所以调试器里看到的就是 `16843009`，而不是 `1`。

------

## 3. 正确写法

因为你只需要布尔意义的 “true/false”，数组应该定义成 `bool` 类型，而不是 `int`：

```
bool isprime[100000005];
memset(isprime, true, sizeof(isprime)); // 每个字节都设为 1，等价于 true
```

如果你非要用 `int` 数组，就别用 `memset`，直接 `fill`：

```
fill(isprime, isprime + 100000005, 1);
```

这样每个元素就真的是 `1`，不是 `16843009`。