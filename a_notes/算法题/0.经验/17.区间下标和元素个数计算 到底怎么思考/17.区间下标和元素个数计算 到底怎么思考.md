ps:下面说的是那个中序遍历和后序遍历建树的题

# 规则与公式（最通用）

- 包含端点的区间 `[L, R]` 中元素个数（**包含 R**）：

  ```
  size = R - L + 1
  ```

- 如果你想表示「从 L 开始，有 size 个元素」的**闭区间**，它的右端点是：

  ```
  R = L + size - 1
  ```

- 不包含右端点的区间（半开区间）`[L, R)` 中元素个数：

  ```
  size = R - L
  ```

  （等价于上面把 `R` 替换成 `R-1` 得到闭区间公式）

# 回到我们题里的 `left_size = index - in_start`

- 语境：中序中左子树是 **`[in_start, index-1]`（闭区间）**，这段**不包含** `index`（因为 `index` 是根）。
- 所以这段的元素个数 = `(index-1) - in_start + 1 = index - in_start`。
   —— 这是 **为什么不用 +1** 的原因：我们求的是左子树的**节点数**（不含根）。

如果你问「如果我要算 `in_start` 到 `index`（包括 index）这一段有多少元素？」

- 那就用包含公式：`size = index - in_start + 1`。
   —— 这正是你指出的那种情况，完全正确，只是语境不同。

# 在后序分区里要特别注意（把公式套进去）

- 已知 `left_size = index - in_start`（左子树节点数）

- 当前后序区间是 `[post_start, post_end]`，`post_end` 是根

  - 左子树后序范围（闭区间）：

    ```
    [post_start, post_start + left_size - 1]
    ```

    （因为从 post_start 开始取 left_size 个元素，右端点 = start + size - 1）

  - 右子树后序范围：

    ```
    [post_start + left_size, post_end - 1]
    ```

# 记忆口诀（不容易混）

- **数量不用减一，加减一只和下标区间有关。**
- **想“有多少个”就用 `R-L+1`（闭区间）或 `R-L`（半开区间）。**
- **想“最后一个下标是多少”就用 `start + size - 1`。**

# 简短示例回顾（加深印象）

中序 `[9, 3, 15, 20, 7]`，`index = 1`，`in_start = 0`：

- `left_size = index - in_start = 1`（左子树 [9]）
- 后序 `[9, 15, 7, 20, 3]`（`post_start=0, post_end=4`）
  - 左子树后序：`[0, 0] = [post_start, post_start + left_size - 1]`
  - 右子树后序：`[1, 3] = [post_start + left_size, post_end - 1]`