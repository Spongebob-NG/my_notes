```
class Solution {
public:
	map<int, int>a;
	TreeNode* helper(vector<int>& preorder, int pre_start, int pre_end, vector<int>& inorder, int in_start, int in_end) {
		if (pre_start > pre_end || in_start > in_end)return NULL;
		TreeNode* root = new TreeNode(preorder[pre_start]);
		int index = a[preorder[pre_start]];
		root->left = helper(preorder, pre_start + 1, pre_start + index - in_start, inorder, in_start, index- 1);
		root->right = helper(preorder, pre_start+index-in_start+1, pre_end, inorder, index + 1, in_end);
		return root;
	}
public:
	TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		for (int i = 0; i < inorder.size(); i++) {
			a[inorder[i]] = i;
		}
		TreeNode* root = helper(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
		return root;
	}
};
```

这道题使用的思想是 **[区间递归+分割点]**

递归终止条件就是不满足正确的区间