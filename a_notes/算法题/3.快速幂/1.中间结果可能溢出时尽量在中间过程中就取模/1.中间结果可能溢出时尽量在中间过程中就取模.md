### 📊 模运算的乘法性质

这个性质可以表述为：

> **两个数乘积的模，等于每个数分别取模后乘积的模** 

用公式表示就是：

```
(a * b) mod m = [(a mod m) * (b mod m)] mod m
```

这意味着，在计算一个大数的幂并对结果取模时（即计算 `a^b mod m`），我们不需要先计算出巨大的 `a^b`再取模（这通常不现实，因为 `a^b`可能非常大），而是可以在**计算过程中的每一步乘法之后立即取模**，保持中间结果在一个可控的大小范围内（小于 `m`），并且最终的结果与先计算整个幂再取模是**一致**的 

。



### 🧠 结合快速幂算法

快速幂算法通过将指数 `b`**二进制分解**，将计算 `a^b`转化为一系列**平方和乘法操作**的组合 

。其迭代实现的核心步骤是：



1. 1.

   初始化结果 `result = 1`。

2. 2.

   遍历指数 `b`的二进制每一位：

   - •

     如果当前最低位为 1，则将当前的底数 `a`乘入结果 `result`。

   - •

     将底数 `a`平方。

   - •

     将指数 `b`右移一位（即除以 2）。

3. 3.

   返回结果 `result`。

为了在计算过程中防止数值溢出，我们利用上述模运算的乘法性质，在**每一步乘法操作之后都立即进行取模操作** 

：



```
result = (result * a) % m; // 乘入后取模
a = (a * a) % m;           // 平方后取模
```



一开始没想明白的点：公式里面是乘法取模，而题目是指数，怎么能用那个公式呢？其实很简单，快速幂的算法内已经把指数转换成乘法了，换句话说，快速幂内部本身就是用乘法完成的，而每一步对m取模，就相当于最终结果result对m取模