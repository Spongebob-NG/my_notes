# 🏃‍♂️ 快慢指针（Floyd 算法）套路总结

## 1. 判断链表是否有环

**思路**：快指针一次走两步，慢指针一次走一步。如果有环，快慢指针一定会在环内相遇；否则快指针会先到 `NULL`。

```
bool hasCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

------

## 2. 找环的入口节点

**思路**：当快慢指针第一次相遇时，把其中一个指针移回头结点，然后两者都一次走一步；再次相遇时，就是入环点。

```
ListNode* detectCycle(ListNode* head) {
    if (!head || !head->next) return NULL;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { // 有环
            ListNode* p = head;
            while (p != slow) {
                p = p->next;
                slow = slow->next;
            }
            return p; // 入环点
        }
    }
    return NULL; // 无环
}
```

------

## 3. 找链表中点

**思路**：快指针一次走两步，慢指针一次走一步。快指针走完时，慢指针在中点。

- 如果链表长度是奇数 → 慢指针在正中间
- 如果链表长度是偶数 → 慢指针在「中间偏右」

```
ListNode* middleNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
```

------

## 4. 判断链表是否回文

**思路**：

1. 用快慢指针找到中点
2. 反转后半段链表
3. 前半段和反转后的后半段逐一比较

```
bool isPalindrome(ListNode* head) {
    if (!head || !head->next) return true;

    // 找中点
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // 反转后半段
    ListNode* prev = NULL;
    while (slow) {
        ListNode* tmp = slow->next;
        slow->next = prev;
        prev = slow;
        slow = tmp;
    }

    // 比较
    ListNode* p1 = head;
    ListNode* p2 = prev;
    while (p2) {
        if (p1->val != p2->val) return false;
        p1 = p1->next;
        p2 = p2->next;
    }
    return true;
}
```

------

# 📌 口诀总结

- **判环**：快慢相遇 → 有环
- **入口**：相遇后 + 一个回头 → 再次相遇就是入口
- **中点**：快走两步慢走一步 → 慢指针到中点
- **回文**：找到中点 → 反转后半段 → 比较