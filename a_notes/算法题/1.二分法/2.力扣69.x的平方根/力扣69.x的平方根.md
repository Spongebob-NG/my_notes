给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```



你这个二分法整体思路是 **对的** 👍，只是有两个小问题：

------

### 📌 你的代码（关键部分）

```
while (left <= right) {
    middle = left + (right - left) / 2;
    if (middle * middle > x) {
        right = middle - 1;
    }
    else if (middle * middle < x) {
        left = middle + 1;
        ans = left;   // ❌ 这里更新错了
    }
    else {
        return middle;
    }
}
if (x == 0) ans = 1;
return ans - 1;
```

------

### ❌ 问题 1：溢出

`middle * middle` 可能超出 `int` 范围（最大 `x = 2^31-1`），必须改成 `long long` 或者用 `middle <= x / middle`。

------

### ❌ 问题 2：`ans = left;`

二分查找里，应该在 **满足条件时更新答案**，你写成了 `ans = left`，会导致偏差。
 正确写法是：

```
ans = middle;   // 而不是 left
```

------

### ❌ 问题 3：`if(x==0) ans=1;`

其实不用单独写 `if(x==0)`，你循环里面已经能处理出来了。

------

### ✅ 改正后的标准写法（保留二分框架）

```
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;  // 特判
        int left = 1, right = x, ans = 0;
        while (left <= right) {
            int middle = left + (right - left) / 2;
            if (middle <= x / middle) {   // ✅ 避免溢出
                ans = middle;             // 记录满足条件的值
                left = middle + 1;        // 往右逼近
            } else {
                right = middle - 1;
            }
        }
        return ans;
    }
};
```

------

### 📊 举个例子：`x = 8`

过程：

| left | right | middle | middle ≤ x/middle? | ans  | 更新方向 |
| ---- | ----- | ------ | ------------------ | ---- | -------- |
| 1    | 8     | 4      | 4 ≤ 2 ❌            | 0    | right=3  |
| 1    | 3     | 2      | 2 ≤ 4 ✅            | 2    | left=3   |
| 3    | 3     | 3      | 3 ≤ 2 ❌            | 2    | right=2  |

循环结束 → 答案 `ans = 2`。

------

👉 结论：你的代码框架没问题，就是 **`ans` 更新和溢出处理**有点小瑕疵。