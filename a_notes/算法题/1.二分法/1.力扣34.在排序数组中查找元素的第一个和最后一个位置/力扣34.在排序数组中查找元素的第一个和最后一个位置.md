给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？

示例 1：

- 输入：nums = [5,7,7,8,8,10], target = 8
- 输出：[3,4]

示例 2：

- 输入：nums = [5,7,7,8,8,10], target = 6
- 输出：[-1,-1]

示例 3：

- 输入：nums = [], target = 0
- 输出：[-1,-1]





这题其实是 **二分查找变形题**，我来一步一步拆开帮你看懂，不然一眼看过去确实容易糊涂。

------

## 🚩题目本质

我们要在有序数组 `nums` 中，找到 **target 的起始位置和结束位置**。
 常见思路有两种：

1. **暴力**：先二分找到一个 target，再往两边扩展（复杂度可能退化到 O(n)）。
2. **二分两次**：分别用二分找 **左边界** 和 **右边界**，复杂度 O(log n)。

这里的代码走的是第二种。

------

## 1️⃣ 左右边界到底是什么？

我们定义两个“虚拟的边界”：

- **左边界（leftBorder）**：**比 target 小的最后一个位置**
- **右边界（rightBorder）**：**比 target 大的第一个位置**

比如：
 `nums = [5,7,7,8,8,10], target = 8`

```
索引:    0 1 2 3 4 5
数组:    5 7 7 8 8 10
```

- target=8 的区间是 `[3, 4]`
- leftBorder = 2 （索引 2 的值是 7，小于 8）
- rightBorder = 5 （索引 5 的值是 10，大于 8）

所以最终答案是 `[leftBorder+1, rightBorder-1] = [3,4]`

------

## 2️⃣ 为什么要这样定义？

因为这样可以统一处理三种情况：

- **情况一：target 在数组外**
   比如 `[3,4,5], target=6`
   左边界=2，右边界=-2（没找到），返回 `[-1,-1]`
- **情况二：target 在范围内，但不存在**
   比如 `[3,6,7], target=5`
   左边界=0，右边界=1
   这时 `rightBorder - leftBorder = 1`，说明 target 不存在。
- **情况三：target 存在**
   比如 `[5,7,7,8,8,10], target=8`
   左边界=2，右边界=5 → `[3,4]`

------

## 3️⃣ 二分过程怎么找边界？

### 找 **左边界**

```
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int leftBorder = -2; // 特殊标记：没被赋值
    while (left <= right) {
        int middle = left + (right - left) / 2;
        if (nums[middle] >= target) {
            right = middle - 1;
            leftBorder = right;   // 更新左边界
        } else {
            left = middle + 1;
        }
    }
    return leftBorder;
}
```

含义：
 当 `nums[middle] >= target` 时，就往左缩，直到找到**比 target 小的最后一个位置**。

------

### 找 **右边界**

```
int getRightBorder(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int rightBorder = -2;
    while (left <= right) {
        int middle = left + (right - left) / 2;
        if (nums[middle] > target) {
            right = middle - 1;
        } else {
            left = middle + 1;
            rightBorder = left;   // 更新右边界
        }
    }
    return rightBorder;
}
```

含义：
 当 `nums[middle] <= target` 时，就往右缩，直到找到**比 target 大的第一个位置**。

------

## 4️⃣ 最终答案怎么得出？

```
vector<int> searchRange(vector<int>& nums, int target) {
    int leftBorder = getLeftBorder(nums, target);
    int rightBorder = getRightBorder(nums, target);
    if (leftBorder == -2 || rightBorder == -2) return {-1, -1}; // target在数组外
    if (rightBorder - leftBorder > 1) return {leftBorder+1, rightBorder-1}; // target存在
    return {-1, -1}; // target不存在
}
```

------

## ✨你困惑的点解答

1. **为什么是 `leftBorder+1` 和 `rightBorder-1`？**
    因为 `leftBorder` 和 `rightBorder` 本身是 **target 的外侧位置**。
   - leftBorder 指向比 target 小的最后一个位置 → 再加 1 就是 target 起点
   - rightBorder 指向比 target 大的第一个位置 → 再减 1 就是 target 终点
2. **为什么要先定义 `-2`？**
    因为有可能 target 根本不在范围里，比如 `[3,3], target=2`。
    此时循环过程中不会更新边界，就能用 `-2` 来判断。