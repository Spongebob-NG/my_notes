通配符是命令行和脚本（比如 Makefile）中的特殊字符，用来**匹配符合特定模式的文件名或路径**，帮你批量操作文件而无需一个个输入名字

。

下面这个表格整理了 Makefile 中常见的通配符及其含义，方便你快速查阅：

| 通配符  | 含义与示例                                                   | 备注                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| `*`     | 匹配**任意数量**的字符（包括0个）。 • `*.c`匹配所有以 `.c`结尾的文件，如 `main.c`, `utils.c`。 | 最常用                    |
| `%`     | Makefile 中**模式规则**特有的通配符，用于定义目标与依赖之间的模式关系。 • `%.o: %.c`表示任何 `.o`文件都依赖于同名的 `.c`文件。 | 主要用于规则定义          |
| `?`     | 匹配**任意一个**字符。 • `doc?.txt`可匹配 `doc1.txt`, `docA.txt`，但不匹配 `doc10.txt`（因为`10`是两个字符）。 | 使用较少                  |
| `[...]` | 匹配方括号内列出的**任意一个**字符。 • `[ab]*.c`匹配以 `a`或 `b`开头，以 `.c`结尾的文件，如 `apple.c`, `banana.c`。 | 可指定字符范围，如`[0-9]` |

### 💡 重要细节与 `wildcard`函数

在使用通配符，特别是 `*`时，有一个关键点需要注意：

- **变量赋值中的通配符不会自动展开**：当你在 Makefile 中定义一个变量时，如果你写成 `SOURCES = *.c`，那么变量 `SOURCES`的值就是字符串 `"*.c"`，而不会自动变成当前目录下所有 `.c`文件的列表

  。这可能导致后续使用这个变量时出错。

- **使用 `wildcard`函数**：为了解决上面这个问题，你需要使用 Makefile 内置的 `wildcard`函数。它会展开通配符，返回匹配的文件列表

  。例如：

  ```
  # 正确做法：使用 wildcard 函数获取.c文件列表
  SOURCES = $(wildcard *.c)
  OBJECTS = $(SOURCES:.c=.o)  # 另一种写法，将SOURCES中所有.c替换为.o
  
  myapp: $(OBJECTS)
      gcc -o $@ $(OBJECTS)
  ```

  这里，`$(wildcard *.c)`会展开为像 `main.c utils.c`这样的文件列表

  。

### ⚠️ 转义通配符

如果你的文件名本身就包含 `*`或 `?`这类字符，需要在它们前面加上反斜杠 `\` 进行转义，以表示这就是一个普通的字符，而不是通配符。例如，文件名为`test*.c`，在 Makefile 中应写为`test*.c`

。

### 📖 简单总结

记住这几点就掌握了 Makefile 通配符的精髓：

- `*`和 `?`主要在命令和规则的目标、依赖中直接使用，由 Shell 或 Make 在读取 Makefile 时展开

  。

- `%`是 Makefile 规则匹配的“专用符”，非常强大，常用于定义通用规则

  。

- 在**变量定义中**想要获得文件列表，务必使用 `$(wildcard pattern)`函数

  。

- 如果文件名含有通配符特殊字符，记得用 ``转义

  。