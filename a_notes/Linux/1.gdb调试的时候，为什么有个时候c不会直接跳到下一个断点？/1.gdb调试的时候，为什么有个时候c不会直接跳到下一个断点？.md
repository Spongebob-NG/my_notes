```
1	#include<iostream>
2	#include<stdio.h>
3	using namespace std;
4	void print(){
5		cout<<"hello world"<<endl;
6		cout<<"这是我想要说给大家听的！！！"<<endl;
7	}
8	int main(int argc,const char*argv[]){
9		int arr[5]={1,2,3,4,5};
10		int i=0;
11		for(int i=0;i<5;i++){
12		cout<<arr[i]<<" ";
13		}
14		cout<<endl;
15		print();
16	    	return 0;
17	}
18		
```

这是一段gdb调试的代码，第一个断点在12行，第二个断点在15行。起初认为指令"c"就是从第一个断点直接运行到第二个断点，所以按下一次c之后能直接输出五个数，但是发现竟然要输五次c才会把arr的五个数输出出来，然后得知：

## ✅ 一句话结论

> GDB 的 `c`（continue）命令确实会**从当前断点运行到下一个断点**，
>  但——**“下一个断点”是“下一次命中任何断点”**，而不是“文件里排在后面的那个断点”。

------

## 🧩 我们一步步模拟你的程序执行

你设置了两个断点：

```
(gdb) b 12   # 断点1，在 for 循环里的 cout
(gdb) b 15   # 断点2，在 print() 语句处
```

### 程序开始运行：

```
for (int i=0; i<5; i++) {
    cout << arr[i] << " ";   // line 12
}
cout << endl;
print();                     // line 15
```

------

### 🚶‍♂️ 第一次执行：

- 程序从 main 开始执行。

- 当执行到 **第12行** 时，命中断点 1。
   GDB 停下，提示你：

  ```
  Breakpoint 1, main() at main.cpp:12
  ```

- 此时 i = 0。

------

### 🧠 你输入 `c`（continue）

> 这一步的意思是：
>  “从当前地方继续执行，直到命中**下一个断点**。”

程序确实继续跑了：

- 打印了 arr[0]（输出 `1`）
- 进入下一轮循环，i = 1
- 再次运行到第12行

❗注意！第12行**本身有一个断点**，而且这时候“下一个断点”指的就是**任何断点的下一次命中**。
 所以它又在第12行停下来了。