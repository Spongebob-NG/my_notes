1. 栈上分配（自动变量）
声明即分配内存：直接声明结构体 / 类的实例，无需显式分配内存。
作用域结束自动释放：无需手动释放内存。

示例：

cpp
运行
struct Queue {
    int* data;
    int f, t;
};

// 栈上分配，无需new
Queue q;  // 内存已分配，可直接使用
q.f = 0;  // 直接访问成员
2. 堆上分配（动态内存）
声明指针后需手动分配内存：先声明指针，再通过 new 分配内存。
需手动释放内存：使用 delete 释放，否则会内存泄漏。

示例：

cpp
运行
Queue* qPtr;  // 仅声明指针，未分配内存
qPtr = new Queue;  // 分配内存
qPtr->f = 0;  // 通过指针访问成员
delete qPtr;  // 释放内存
3. 常见误区
指针必须初始化：若未初始化，指针指向随机地址，解引用会导致段错误。
cpp
运行
Queue* qPtr;  // 危险！未初始化的指针
qPtr->f = 0;  // 段错误！

栈上变量无需 new：直接使用变量名访问成员，无需 ->。
cpp
运行
Queue q;
q.f = 0;  // 正确
q->f = 0;  // 错误！q不是指针

4. 结构体中的指针成员
结构体本身的内存：栈或堆分配（取决于声明方式）。
结构体内部的指针成员：需单独初始化，否则指向随机地址。

示例：

cpp
运行
// 栈上分配结构体，但内部指针未初始化
Queue q;
q.data = new int[10];  // 必须手动初始化data

// 堆上分配结构体，内部指针仍需初始化
Queue* qPtr = new Queue;
qPtr->data = new int[10];  // 必须手动初始化data
5. 智能指针（现代 C++ 推荐）
自动管理内存：避免手动 new/delete，减少内存泄漏。

示例：

cpp
运行
#include <memory>

// 使用unique_ptr管理堆上的Queue
std::unique_ptr<Queue> qPtr = std::make_unique<Queue>();
qPtr->data = new int[10];  // 仍需初始化内部指针

// 离开作用域时，qPtr自动释放内存
总结
场景	是否需要显式分配内存	示例
栈上分配结构体 / 类实例	❌ 否	Queue q;
堆上分配结构体 / 类指针	✅ 是（使用 new）	Queue* q = new Queue;
初始化结构体 / 类中的指针成员	✅ 是（无论栈或堆分配）	q.data = new int[10];
回到你的队列实现
在你的队列代码中：

栈上分配：
cpp
运行
Queue q;        // 栈上分配结构体
init(&q);       // 通过指针初始化内部指针data

堆上分配：
cpp
运行
Queue* qPtr = new Queue;  // 堆上分配结构体
init(qPtr);               // 通过指针初始化内部指针data
delete qPtr;              // 手动释放内存


智能指针版本：
cpp
运行
auto qPtr = std::make_unique<Queue>();  // 自动管理内存
init(qPtr.get());                       // init接收原始指针



无论哪种方式，结构体内部的指针成员（如 data）必须单独初始化，否则会导致空指针解引用