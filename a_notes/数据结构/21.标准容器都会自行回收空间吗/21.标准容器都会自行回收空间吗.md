在 C++ 中，标准容器（如 std::vector、std::queue、std::map 等）都遵循 “自动内存管理” 规则，即离开作用域时会自动调用析构函数释放内存，无需手动回收。但这一特性的适用范围和细节需要明确：
一、标准容器的 “自动管理” 是普遍的
所有 C++ 标准库容器（包括序列式容器如 vector、list，关联式容器如 map、set，以及容器适配器如 queue、stack）都具备以下特点：

自动析构：当容器对象超出作用域（如函数结束、代码块执行完毕）时，会自动调用析构函数。
递归释放：不仅释放容器自身占用的内存，还会自动销毁容器中存储的所有元素（调用元素的析构函数），并释放元素占用的内存。

例如：

cpp
运行
#include <vector>
#include <string>

void test() {
    std::vector<std::string> vec;
    vec.push_back("hello");  // 元素存入容器
    // 函数结束时，vec 自动析构：
    // 1. 销毁内部的 string 元素（释放字符串内存）
    // 2. 释放 vector 自身的底层数组内存
}
二、特殊情况：容器中存储 “指针” 时需注意
如果容器存储的是指针类型（如 std::vector<int*>），容器的自动析构仅会释放指针本身的内存（即指针变量占用的空间），但不会自动释放指针指向的内存。此时需要手动管理指针指向的资源，否则会导致内存泄漏。

示例（错误写法）：

cpp
运行
#include <vector>

void test() {
    std::vector<int*> ptrVec;
    ptrVec.push_back(new int(10));  // 存储动态分配的指针
    // 容器析构时，仅释放 ptrVec 中的指针变量，
    // 但 new int(10) 分配的内存未释放，导致内存泄漏！
}

正确做法：手动释放指针指向的内存（或使用智能指针 std::shared_ptr/std::unique_ptr 自动管理）：

cpp
运行
#include <vector>
#include <memory>  // 智能指针头文件

void test() {
    // 方法1：手动释放
    std::vector<int*> ptrVec;
    ptrVec.push_back(new int(10));
    for (int* p : ptrVec) {
        delete p;  // 手动释放指针指向的内存
    }

    // 方法2：使用智能指针（推荐）
    std::vector<std::unique_ptr<int>> smartVec;
    smartVec.push_back(std::make_unique<int>(10));
    // 智能指针会自动释放指向的内存，无需手动操作
}
三、非标准容器：依赖具体实现
如果是自定义容器（非标准库容器），其内存管理规则由实现者决定：

若自定义容器遵循 RAII 原则（资源获取即初始化），则同样支持自动析构和内存释放。
若实现不规范（如未在析构函数中释放内存），则可能需要手动调用释放函数（如 clear() 或自定义的 free() 方法）。
总结
标准容器：无论存储的是基本类型（int、double）还是对象（std::string、自定义类），只要不存储 “裸指针”，就无需手动回收内存，依赖自动析构即可。
存储指针的容器：需手动释放指针指向的资源（或用智能指针规避风险）。
自定义容器：需看其是否实现了完善的析构逻辑，不能默认 “自动管理”。

核心原则：C++ 标准容器的设计目标是 “开箱即用” 的内存安全，只要不涉及裸指针，就无需担心手动回收问题。
