#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int prim(vector<vector<int>>& graph, int n) {
    vector<int> lowcost(n, INT_MAX); // 记录当前生成树到每个点的最小边
    vector<int> visited(n, 0);       // 是否已经在生成树中

    int mst_weight = 0;
    lowcost[0] = 0; // 从0号点开始
    
    for (int i = 0; i < n; i++) {
        int u = -1, minCost = INT_MAX;
    
        // 找到当前不在树中的、距离最小的点
        for (int j = 0; j < n; j++) {
            if (!visited[j] && lowcost[j] < minCost) {
                minCost = lowcost[j];
                u = j;
            }
        }
    
        if (u == -1) return -1; // 图不连通
        visited[u] = 1;
        mst_weight += minCost;
    
        // 更新：用u点去更新其他点的最小边
        for (int v = 0; v < n; v++) {
            if (!visited[v] && graph[u][v] < lowcost[v]) {
                lowcost[v] = graph[u][v];
            }
        }
    }
    
    return mst_weight;
}

int main() {
    int n, m;
    cin >> n >> m;

    // 初始化邻接矩阵
    vector<vector<int>> graph(n, vector<int>(n, INT_MAX));
    for (int i = 0; i < n; i++) graph[i][i] = 0;
    
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        graph[u][v] = graph[v][u] = w; // 无向图
    }
    
    int ans = prim(graph, n);
    if (ans == -1) cout << "图不连通" << endl;
    else cout << "最小生成树权值 = " << ans << endl;
}



在 Prim 算法里，我们每一轮都要从 **未加入生成树的点** 里找一个 “距离生成树最近的点”（也就是 `lowcost[j]` 最小的点）。

------

### 📌 回忆代码里的这一段：

```
int u = -1, minCost = INT_MAX;
for (int j = 0; j < n; j++) {
    if (!visited[j] && lowcost[j] < minCost) {
        minCost = lowcost[j];
        u = j;
    }
}
```

- `u` 代表：这一轮我们找出的、要加入生成树的点。
- 如果最后 `u == -1`，说明 **所有未加入树的点** 的 `lowcost[j]` 依然是 `INT_MAX`。
   👉 这就表示：生成树里根本没有任何边能连到这些点。

换句话说：

- 生成树那一边 → 根本到不了剩下的点
- 那么图就不连通。

------

### 📖 举个例子

输入：

```
4 2
0 1 1
2 3 1
```

图长这样：

- 点 0 和 1 连着（权重 1）
- 点 2 和 3 连着（权重 1）
- 但是 {0,1} 和 {2,3} 之间没边

Prim 从 0 开始：

- 会先加 1 进去
- 但是 2 和 3 的 `lowcost` 始终是 `INT_MAX`，永远不会被更新
- 遍历完一次后，`u` 找不到可选点（`u == -1`），就说明图不连通