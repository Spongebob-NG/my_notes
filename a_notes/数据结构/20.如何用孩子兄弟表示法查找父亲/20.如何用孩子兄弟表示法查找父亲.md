没问题！用孩子兄弟表示法（左孩子右兄弟）查找父节点确实需要遍历整棵树，但可以通过递归或迭代实现。下面我提供两种实现方式：
方法 1：递归遍历全树查找父节点
从根节点开始，递归检查每个节点的子树中是否包含目标节点，如果包含则返回该节点作为父节点：

cpp
运行
// 查找节点a的父节点（递归实现）
node* findParent(node* root, char a) {
    if (root == NULL) return NULL;
    
    // 检查当前节点的子节点中是否有目标节点
    node* child = root->son;
    while (child != NULL) {
        if (child->data == a) {
            return root; // 找到目标节点，返回当前节点作为父节点
        }
        child = child->bro;
    }
    
    // 递归检查左子树（孩子的子树）
    node* leftResult = findParent(root->son, a);
    if (leftResult != NULL) return leftResult;
    
    // 递归检查右子树（兄弟的子树）
    return findParent(root->bro, a);
}
方法 2：迭代层序遍历（效率更高）
使用队列进行层序遍历，逐层检查每个节点的子节点是否为目标节点：

cpp
运行
#include <queue>

// 查找节点a的父节点（迭代层序遍历实现）
node* findParent(node* root, char a) {
    if (root == NULL) return NULL;
    
    std::queue<node*> q;
    q.push(root);
    
    while (!q.empty()) {
        node* current = q.front();
        q.pop();
        
        // 检查当前节点的所有子节点
        node* child = current->son;
        while (child != NULL) {
            if (child->data == a) {
                return current; // 找到目标节点，返回当前节点作为父节点
            }
            // 将子节点加入队列继续遍历
            if (child->son != NULL) q.push(child->son);
            child = child->bro;
        }
    }
    
    return NULL; // 未找到
}
使用示例
在你的代码中，可以这样调用：

cpp
运行
// 在main函数中查找节点的父节点
cout << "输入要查找父节点的节点: ";
char target;
cin >> target;

node* parent = findParent(t, target);
if (parent != NULL) {
    cout << target << "的父节点是: " << parent->data << endl;
} else {
    cout << "未找到该节点或该节点是根节点" << endl;
}
复杂度分析
时间复杂度：两种方法均需遍历树的所有节点，最坏情况下为 
O(n)
，其中 
n
 是树的节点数。
空间复杂度：
递归方法：最坏情况下 
O(h)
（树高，即递归栈深度）。
迭代方法：最坏情况下 
O(w)
（树的最大宽度，即队列的最大长度）。

虽然这种方法效率不高，但在没有父指针的情况下是唯一可行的方案。如果需要频繁查找父节点，建议还是在节点结构中添加 parent 指针。