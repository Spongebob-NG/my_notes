当使用值传递时：

结构体的指针成员（如 data）会复制指针值（即内存地址），因此副本和原始结构体的指针指向同一块内存。修改这块内存中的数据（如 l.data[i] = x）会影响原始数据。
结构体的普通成员（如 int f, t）会复制值本身，修改副本的这些成员不会影响原始结构体。
关键区别图示
假设原始结构体 l 的 data 指向地址 0x1000，t 的值为 0：

plaintext
原始结构体 l:
┌───────────┐
│ data: 0x1000 ├───→ [内存地址0x1000]
│ t: 0        │     [0, 0, 0, 0, 0]
└───────────┘

值传递到函数后创建的副本:
┌───────────┐
│ data: 0x1000 ├───→ [内存地址0x1000]
│ t: 0        │     [0, 0, 0, 0, 0]
└───────────┘

修改 l.data[0] = 1：副本和原始结构体的 data 指向同一块内存，因此原始数据会被修改。
修改 l.t = 1：副本的 t 变为 1，但原始结构体的 t 仍为 0。
常见误解澄清
你可能会混淆 “修改指针本身” 和 “修改指针指向的数据”：

修改指针本身（如让指针指向新内存）：值传递无法实现。例如，在函数中让副本的 data 指向新分配的内存，原始结构体的 data 不会改变。
修改指针指向的数据：值传递可以实现。因为副本和原始的指针指向同一块内存。
为什么队列不能用值传递？
队列的核心逻辑依赖于 f 和 t 的正确更新。如果使用值传递：

add 函数无法更新原始的 t，导致每次入队都覆盖第一个元素。
dele 函数无法更新原始的 f，导致无法正确出队。
队列状态（空 / 满）判断基于副本的 f 和 t，与原始结构体无关。
总结
操作	值传递	指针 / 引用传递
修改结构体的普通成员	❌ 无效	✅ 有效
修改结构体指针成员指向的数据	✅ 有效	✅ 有效
修改结构体指针成员本身	❌ 无效	✅ 有效

因此，对于需要维护内部状态的结构体（如队列），必须使用指针或引用传递。