Prim 里是通过 `u == -1` 来判断「没法再扩展」，那在 **Kruskal 算法** 里判断图是否连通的方法就不太一样了。

------

### 📌 Kruskal 的关键点：

1. Kruskal 每次选一条最小边，如果它能连接两个不同的连通块（用并查集判断），就加入生成树。
2. 如果最后一共加入了 **`n-1` 条边**（这里 `n` 是点的数量），那么图一定是连通的。
3. 如果最后加入的边数 **小于 `n-1`**，说明有些点无法连起来 → 图不连通。

------

### 📖 举个例子

```
4 2
1 2 1
3 4 2
```

- 图有 4 个点、2 条边。
- Kruskal 会选两条边，但此时只连成两个分量：{1,2} 和 {3,4}。
- 最后选中的边数 = 2，小于 4-1=3 → 说明不连通。

------

### 📌 代码里怎么写？

在你之前的 Kruskal 代码里，只要最后检查一下 **选中的边数 `cnt`** 就行：

```
int kruskal(vector<Edge>& edges,int n,int m) {
    sort(edges.begin(), edges.begin() + m, [](Edge a, Edge b) {return a.w < b.w; });
    vector<int> parent(n+1);
    for (int i = 1; i <= n; i++) parent[i] = i;

    int s_weight=0;
    int cnt = 0;
    for (int i = 0; i < m; i++) {
        if (unite(edges[i].u, edges[i].v, parent)) {
            s_weight += edges[i].w;
            cnt++;
        }
    }

    if (cnt < n-1) {
        cout << "图不连通" << endl;
        return -1;  // 特殊标记
    }

    return s_weight;
}
```