你的观察非常细致！在destroy函数中，确实只释放了内存但没有将每个节点的next指针置为nullptr。不过，这在该场景下是合理的，原因如下：
1. 为什么不需要将节点的next指针置为nullptr？
当我们释放一个节点时，该节点的整个内存空间已被回收，包括其next指针。此时再去修改这个已释放的指针是未定义行为（访问无效内存）。例如：

cpp
运行
delete temp;  // temp指向的内存已释放
temp->next = nullptr;  // 错误！访问已释放的内存

在destroy函数中，我们通过l = l->next将指针移动到下一个节点，在删除当前节点前已保存了下一个节点的地址，因此不需要担心后续节点丢失。
2. 那为什么删除单个节点时需要p = nullptr？
在删除单个节点的函数（如deleteNode）中，我们通常会这样做：

cpp
运行
q->next = p->next;  // 断开p的连接
delete p;           // 释放p的内存
p = nullptr;        // 将p（局部变量）置为nullptr

这里的p = nullptr是为了防止后续代码误用这个局部指针变量（避免野指针）。但请注意，这只是将 ** 局部变量p** 置为nullptr，而不是修改已删除节点的内存内容。
3. 什么时候需要置nullptr？
只有当指针变量仍在作用域内且可能被再次使用时，才需要置nullptr。例如：

cpp
运行
node* p = find(l, 5);
delete p;
p = nullptr;  // 防止后续误用p

// 此时p为nullptr，安全
if (p == nullptr) {
    cout << "p已被安全释放" << endl;
}
4. destroy函数的完整逻辑
cpp
运行
void destroy(node*& l) {
    while (l != nullptr) {
        node* temp = l;      // 保存当前节点指针
        l = l->next;         // 移动到下一个节点（关键！）
        delete temp;         // 释放当前节点
        // temp = nullptr;  // 不需要！temp是局部变量，离开作用域即失效
    }
    l = nullptr;             // 最后将头指针置为nullptr（重要！）
}

关键点：通过l = l->next提前保存下一个节点的地址，确保删除当前节点后仍能访问后续节点。
最终效果：链表所有节点被释放，头指针l被置为nullptr，表示链表为空。
5. 对比：错误的实现方式
以下代码是错误的，因为它在释放节点后尝试访问已释放的内存：

cpp
运行
void wrong_destroy(node*& l) {
    while (l != nullptr) {
        delete l;           // 释放内存
        l->next = nullptr;  // 错误！访问已释放的内存
        l = l->next;        // 错误！
    }
}
总结
在destroy函数中：

不需要将节点的next指针置为nullptr，因为节点内存已释放，修改它是未定义行为。
需要将头指针l置为nullptr，确保调用者无法再通过原头指针访问已释放的内存。
局部指针变量（如temp）无需置nullptr，因为它们离开作用域后自动失效。
人为创建的指针变量（如p） 是我们主动声明的，它的作用域可能覆盖后续代码。如果不把它置为nullptr，后续不小心用它判断 “是否为空” 或访问其指向的内存，就会出问题。
temp这类临时指针变量 是循环内部的局部变量，每次循环结束后就会被销毁（出了作用域），后续代码根本没有机会再使用它。既然不会被误用，自然不需要多此一举地置空。

简单说就是：“谁可能被后续代码碰到，就给谁置空；碰不到的，没必要折腾”。这也是 C++ 中处理指针时 “最小必要原则” 的体现 —— 只做能避免风险的操作，不做无意义的冗余操作。