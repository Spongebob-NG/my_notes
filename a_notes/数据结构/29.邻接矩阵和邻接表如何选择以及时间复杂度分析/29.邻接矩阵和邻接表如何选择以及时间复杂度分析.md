图的两种主要存储结构——邻接矩阵和邻接表，在进行图的遍历（如广度优先搜索 BFS 或深度优先搜索 DFS）时，其时间复杂度确实有显著差异，这主要源于它们不同的物理结构。

下面是一个表格，帮你快速梳理它们在不同操作下的时间复杂度差异：

| 操作描述 (Operation)                   | 邻接矩阵 (Adjacency Matrix) | 邻接表 (Adjacency List) |
| :------------------------------------- | :-------------------------- | :---------------------- |
| **初始化**                             | O(V²)                       | O(V)                    |
| **判断是否存在边 between u and v**     | **O(1)**                    | O(degree(u)) 或 O(V)    |
| **查找顶点 u 的所有邻接点 (遍历邻居)** | O(V)                        | **O(degree(u))**        |
| **添加一条边**                         | O(1)                        | O(1)                    |
| **删除一条边**                         | O(1)                        | O(degree(u)) 或 O(V)    |
| **图的遍历 (BFS/DFS)**                 | **O(V²)**                   | **O(V + E)**            |

*注：V 表示顶点数量，E 表示边数量，degree(u) 表示顶点 u 的度（邻接点数）。*

### 🔍 时间复杂度分析

从表格中可以看到：

1. 1.

   **邻接矩阵的遍历时间复杂度为 O(V²)**：
   这是因为在邻接矩阵中，算法需要访问矩阵中的每一个元素（V * V 个）来确定顶点之间是否存在边。虽然实际存在的边可能很少，但遍历过程无法跳过不存在的边（即矩阵中的0）。对于稠密图（边数 E 接近 V²）来说，这个复杂度可以接受；但对于稀疏图，就显得效率低下了

   。

   

2. 2.

   **邻接表的遍历时间复杂度为 O(V + E)**：
   邻接表只为实际存在的边分配存储空间。遍历时，算法会访问所有顶点（V 个）和所有边的节点（E 个）。DFS 和 BFS 在每个顶点和每条边上都只处理一次，因此总时间复杂度是顶点数加上边数，即 O(V + E)

   。对于稀疏图，这比邻接矩阵高效得多。

   

### 🧭 如何选择存储结构

选择邻接矩阵还是邻接表，主要取决于图的**稠密度**和你的**常见操作**：

- •

  **邻接矩阵**更适用于**稠密图**（边数接近最大可能边数），或者需要**频繁判断任意两个顶点间是否存在边**的场景

  。

- •

  **邻接表**则更适用于**稀疏图**（边数远小于最大可能边数），以及需要**频繁遍历某个顶点的所有邻接点**或进行**图的遍历**算法的场景

  。绝大多数实际应用中的图（如社交网络、交通网络）都是稀疏图，因此邻接表更为常用。

### 💡 一个重要的辨析

你可能会注意到，在邻接表中“判断是否存在边”的时间复杂度是 O(degree(u)) 或 O(V)，这似乎比邻接矩阵的 O(1) 要差。这正体现了**不同数据结构在时间效率上的权衡（Trade-off）**：邻接表牺牲了快速判边的能力，换来了对稀疏图更高效的整体遍历和更小的空间占用。

ps:上面提到的degree是度