是的，在 C++ 里，当二维数组作为函数参数传递时，必须明确指定第二维（及后续维度）的大小。这是由 C++ 处理多维数组的内存布局方式所决定的。
详细原因
C++ 的多维数组在内存中是连续存储的。以二维数组int arr[3][4]为例，它在内存里会被线性存储为 12 个连续的整数。当我们使用arr[i][j]来访问元素时，编译器会通过如下公式计算内存地址：

plaintext
&arr[i][j] = base_address + (i * 4 + j) * sizeof(int)

这里的4就是第二维的大小。要是编译器不知道第二维的大小，就无法正确计算元素的内存地址。
示例代码
下面是几种传递二维数组的正确方式：
1. 明确指定两个维度的大小
cpp
运行
void func(int arr[3][4]) {
    arr[0][0] = 100;  // 直接修改原数组
}
2. 只指定第二维的大小
cpp
运行
void func(int arr[][4], int rows) {
    arr[1][2] = 200;  // 正确：可以处理任意行数
}
3. 使用指向数组的指针
cpp
运行
void func(int (*arr)[4], int rows) {
    arr[2][3] = 300;  // 与上面等价
}
4. 使用std::vector（更推荐的做法）
cpp
运行
#include <vector>
void func(std::vector<std::vector<int>>& arr) {
    arr[0][0] = 400;  // 可以处理任意维度
}
错误示例
下面这样的写法是错误的：

cpp
运行
void func(int arr[][], int rows, int cols);  // 错误：必须指定第二维大小
void func(int arr[3][]);                      // 错误：只能省略第一维

为什么第一维可以省略？
第一维代表的是数组的行数，而函数在处理二维数组时，通常不需要提前知道行数。因为行数会在运行时动态确定（比如通过另一个参数rows来传递）。但第二维的大小是编译器计算偏移量所必需的，所以必须明确指定。
总结
必须指定第二维的大小，这样编译器才能正确计算元素的内存地址。
推荐使用std::vector来替代原生数组，因为它能更灵活地处理多维数组，还能自动管理内存。