在 C++ 中，内存分配位置（栈 vs 堆）是编程的基础概念，理解它们的区别对避免内存错误至关重要。以下是详细解释：
1. 栈内存（Stack） vs 堆内存（Heap）
（1）栈内存（Stack）
分配方式：由编译器自动管理，函数内的局部变量、参数、返回地址等都存储在栈上。
生命周期：随函数调用创建，函数返回时自动销毁。
特点：
分配和释放速度快（由 CPU 指令直接管理）。
空间有限（通常几 MB 到几十 MB，取决于系统）。
连续内存块，后进先出（LIFO）。
（2）堆内存（Heap）
分配方式：通过new/malloc手动申请，delete/free手动释放。
生命周期：需程序员手动管理，直到释放或程序结束。
特点：
空间较大（受限于物理内存和虚拟内存）。
分配和释放较慢（涉及系统调用和内存碎片管理）。
非连续分配，可能产生内存碎片。
2. 如何区分栈和堆？
（1）栈上内存的特征
自动变量：函数内直接声明的变量（无需new）。
数组：直接声明的数组（非动态分配）。
函数参数和局部变量：

cpp
运行
void func() {
    int x = 10;              // 栈上的变量
    int stackArr[10];        // 栈上的数组（10个int，连续存储）
    std::string str = "abc"; // 栈上的对象（但对象内部可能管理堆内存）
} // 函数结束时，所有栈变量自动销毁
（2）堆上内存的特征
动态分配：通过new/malloc返回的指针。
生命周期手动控制：需显式释放。

cpp
运行
void func() {
    int* ptr = new int(10);      // 堆上的单个int
    int* heapArr = new int[10];  // 堆上的数组（10个int）
    std::string* strPtr = new std::string("abc"); // 堆上的对象
    
    delete ptr;
    delete[] heapArr;
    delete strPtr;
} // 若未手动释放，堆内存会泄漏
3. 关键区别总结
特性	栈内存	堆内存
分配方式	自动（函数调用时）	手动（new/malloc）
释放方式	自动（函数返回时）	手动（delete/free）
内存管理	编译器负责	程序员负责
效率	极高（CPU 直接管理）	较低（涉及系统调用）
空间大小	较小（几 MB 到几十 MB）	较大（受物理内存限制）
内存连续性	连续	非连续
典型示例	int x; int arr[10];	int* ptr = new int[10];
4. 为什么不能对栈上数组使用 delete[]？
delete[] 的作用：告诉操作系统 “释放由new[]分配的堆内存，并调用元素析构函数”。
栈上数组的生命周期：由编译器自动管理，函数结束时已被销毁。若再用delete[]释放，会导致：
访问无效内存：栈空间已被回收，操作非法地址。
程序崩溃：操作系统检测到非法内存访问。

错误示例：

cpp
运行
int stackArr[10];  // 栈上分配10个int
delete[] stackArr; // 错误！栈内存不能用delete[]释放
// 等价于：delete[] &stackArr[0];（取数组首地址）
5. 常见内存错误
（1）栈溢出（Stack Overflow）
原因：栈空间耗尽（如递归过深或创建过大数组）。
示例：

cpp
运行
void recursiveFunc() {
    char bigArray[1000000]; // 栈上分配1MB数组
    recursiveFunc(); // 无限递归，最终栈溢出
}
（2）堆内存泄漏（Memory Leak）
原因：new后未delete，导致内存无法回收。
示例：

cpp
运行
void leakMemory() {
    int* ptr = new int[1000]; // 分配1000个int
    // 未delete[] ptr; 函数返回后内存泄漏
}
（3）悬空指针（Dangling Pointer）
原因：释放内存后仍使用指针。
示例：

cpp
运行
int* ptr = new int(10);
delete ptr;
*ptr = 20; // 错误！ptr指向已释放的内存
6. 现代 C++ 的最佳实践
优先使用栈内存：对于小对象和局部变量，避免不必要的堆分配。
用智能指针管理堆内存：
std::unique_ptr：独占所有权，自动释放。
std::shared_ptr：共享所有权，引用计数为 0 时释放。
std::vector/std::string：自动管理内部堆内存。

cpp
运行
// 推荐写法：无需手动释放
std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);
std::vector<int> vec(10); // 内部使用堆内存，但由vector管理

总结
栈内存：自动分配和释放，适合局部变量和小对象。
堆内存：手动分配和释放，适合大对象或生命周期灵活的场景。
区分方法：看是否使用new/malloc，有则为堆，否则为栈。
安全原则：栈变量无需delete，堆内存必须配对使用new/delete。